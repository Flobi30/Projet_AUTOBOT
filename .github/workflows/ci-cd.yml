Voici un exemple de workflow GitHub Actions qui teste, construit une image Docker, la pousse vers un registre Docker et déploie l'image sur un cluster Kubernetes. Ce workflow suppose que vous avez déjà configuré votre cluster Kubernetes et que vous avez les permissions nécessaires pour y déployer des applications.

### Fichier de workflow GitHub Actions

Créez un fichier `.github/workflows/deploy.yml` dans votre dépôt avec le contenu suivant :

```yaml
name: CI/CD Pipeline

on:
  push:
    branches:
      - main  # Changez cela selon votre branche principale
  pull_request:
    branches:
      - main  # Changez cela selon votre branche principale

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Cache Docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build Docker image
        run: |
          docker build -t my-image:${{ github.sha }} .

      - name: Run tests
        run: |
          docker run --rm my-image:${{ github.sha }} npm test  # Changez cette commande selon votre projet

      - name: Log in to Docker Hub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Push Docker image
        run: |
          docker tag my-image:${{ github.sha }} my-docker-repo/my-image:${{ github.sha }}
          docker push my-docker-repo/my-image:${{ github.sha }}

  deploy:
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up kubectl
        uses: azure/setup-kubectl@v1
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 --decode > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Deploy to Kubernetes
        run: |
          kubectl set image deployment/my-deployment my-container=my-docker-repo/my-image:${{ github.sha }}
          kubectl rollout status deployment/my-deployment
```

### Explications des étapes

1. **Déclencheurs** : Le workflow se déclenche sur les `push` et `pull_request` vers la branche `main`.

2. **Job Build** :
   - **Checkout code** : Récupère le code source du dépôt.
   - **Set up Docker Buildx** : Configure Docker Buildx pour construire des images.
   - **Cache Docker layers** : Met en cache les couches Docker pour accélérer les builds.
   - **Build Docker image** : Construit l'image Docker à partir du Dockerfile.
   - **Run tests** : Exécute les tests dans le conteneur Docker.
   - **Log in to Docker Hub** : Se connecte à Docker Hub en utilisant des secrets (vous devez ajouter `DOCKER_USERNAME` et `DOCKER_PASSWORD` dans les secrets de votre dépôt).
   - **Push Docker image** : Tag et pousse l'image Docker vers votre registre.

3. **Job Deploy** :
   - **Checkout code** : Récupère à nouveau le code source.
   - **Set up kubectl** : Installe `kubectl` pour interagir avec Kubernetes.
   - **Configure kubectl** : Configure `kubectl` avec le fichier de configuration Kubernetes (vous devez ajouter `KUBE_CONFIG` dans les secrets de votre dépôt, encodé en base64).
   - **Deploy to Kubernetes** : Met à jour l'image du déploiement Kubernetes avec la nouvelle image Docker et attend que le déploiement soit terminé.

### Remarques

- Assurez-vous de remplacer `my-image`, `my-docker-repo`, `my-deployment`, et `my-container` par les valeurs appropriées pour votre projet.
- Vous devez également configurer les secrets dans votre dépôt GitHub pour Docker Hub et Kubernetes.
- Adaptez les commandes de test et de construction selon les besoins de votre projet.